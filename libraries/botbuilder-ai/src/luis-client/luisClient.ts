/**
 * LUIS Runtime Client
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { LuisResult } from './model/luisResult';

import { ObjectSerializer, Authentication, VoidAuth } from './model/models';
import { ApiKeyAuth } from './model/models';

let luisVersion = '/luis/v2.0';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum LuisApikeys {
    apiKeyHeader,
}

export class LuisClient {
    protected _basePath: string = '';
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        'default': new VoidAuth() as Authentication,
        'apiKeyHeader': new ApiKeyAuth('header', 'Ocp-Apim-Subscription-Key'),
    }

    public constructor(basePath: string){
        if (basePath) {
            this.basePath = basePath + luisVersion;
        }
    }

    public set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public set basePath(basePath: string) {
        this._basePath = basePath;
    }

    public get basePath(): string {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication): void {
        this.authentications.default = auth;
    }

    public setApiKey(key: LuisApikeys, value: string): void {
        (this.authentications as any)[LuisApikeys[key]].apiKey = value;
    }

    /**
     * Gets predictions for a given utterance, in the form of intents and entities. The current maximum query size is 500 characters.
     * @param q The utterance to predict.
     * @param appId The LUIS application ID (Guid).
     * @param timezoneOffset The timezone offset for the location of the request.
     * @param verbose If true, return all intents instead of just the top scoring intent.
     * @param staging Use the staging endpoint slot.
     * @param spellCheck Enable spell checking.
     * @param bingSpellCheckSubscriptionKey The subscription key to use when enabling Bing spell check
     * @param log Log query (default is true)
     */
    public async predictionResolvePost(q: string, appId: string, timezoneOffset?: number, verbose?: boolean, staging?: boolean, spellCheck?: boolean, bingSpellCheckSubscriptionKey?: string, log?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}): Promise<LuisResult> {
        const localVarPath = this.basePath + '/apps/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams = (Object as any).assign({}, this.defaultHeaders) as any;
        let localVarFormParams: any = {};

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling predictionResolve.');
        }

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling predictionResolve.');
        }

        if (timezoneOffset !== undefined) {
            localVarQueryParameters['timezoneOffset'] = ObjectSerializer.serialize(timezoneOffset, 'number');
        }

        if (verbose !== undefined) {
            localVarQueryParameters['verbose'] = ObjectSerializer.serialize(verbose, 'boolean');
        }

        if (staging !== undefined) {
            localVarQueryParameters['staging'] = ObjectSerializer.serialize(staging, 'boolean');
        }

        if (spellCheck !== undefined) {
            localVarQueryParameters['spellCheck'] = ObjectSerializer.serialize(spellCheck, 'boolean');
        }

        if (bingSpellCheckSubscriptionKey !== undefined) {
            localVarQueryParameters['bing-spell-check-subscription-key'] = ObjectSerializer.serialize(bingSpellCheckSubscriptionKey, 'string');
        }

        if (log !== undefined) {
            localVarQueryParameters['log'] = ObjectSerializer.serialize(log, 'boolean');
        }

        (Object as any).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            maxRedirects: 21,
            body: ObjectSerializer.serialize(q, 'string')
        };

        this.authentications.apiKeyHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<LuisResult>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, luisResult) => {
                if (error) {
                    reject(error);
                } else {
                    luisResult = ObjectSerializer.deserialize(luisResult, 'LuisResult');
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve(luisResult);
                    } else {
                        reject({
                            response: {
                                response: response,
                                headers:
                                    response.headers,
                                body: response.body,
                                status:
                                    response.statusCode
                            }
                        });
                    }
                }
            });
        });
    }
    /**
     * Gets predictions for a given utterance, in the form of intents and entities. The current maximum query size is 500 characters.
     * @param appId The LUIS application ID (guid).
     * @param q The utterance to predict.
     * @param timezoneOffset The timezone offset for the location of the request.
     * @param verbose If true, return all intents instead of just the top scoring intent.
     * @param staging Use the staging endpoint slot.
     * @param spellCheck Enable spell checking.
     * @param bingSpellCheckSubscriptionKey The subscription key to use when enabling Bing spell check
     * @param log Log query (default is true)
     */
    public async predictionResolveGet(appId: string, q: string, timezoneOffset?: number, verbose?: boolean, staging?: boolean, spellCheck?: boolean, bingSpellCheckSubscriptionKey?: string, log?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LuisResult; }> {
        const localVarPath = this.basePath + '/apps/{appId}'
            .replace('{' + 'appId' + '}', encodeURIComponent(String(appId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (Object as any).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appId' is not null or undefined
        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling predictionResolve2.');
        }

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling predictionResolve2.');
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, 'string');
        }

        if (timezoneOffset !== undefined) {
            localVarQueryParameters['timezoneOffset'] = ObjectSerializer.serialize(timezoneOffset, 'number');
        }

        if (verbose !== undefined) {
            localVarQueryParameters['verbose'] = ObjectSerializer.serialize(verbose, 'boolean');
        }

        if (staging !== undefined) {
            localVarQueryParameters['staging'] = ObjectSerializer.serialize(staging, 'boolean');
        }

        if (spellCheck !== undefined) {
            localVarQueryParameters['spellCheck'] = ObjectSerializer.serialize(spellCheck, 'boolean');
        }

        if (bingSpellCheckSubscriptionKey !== undefined) {
            localVarQueryParameters['bing-spell-check-subscription-key'] = ObjectSerializer.serialize(bingSpellCheckSubscriptionKey, 'string');
        }

        if (log !== undefined) {
            localVarQueryParameters['log'] = ObjectSerializer.serialize(log, 'boolean');
        }

        (Object as any).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.apiKeyHeader.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LuisResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, 'LuisResult');
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
